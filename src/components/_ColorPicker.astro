---
// ⚠️ Internal component. Not part of mCSS component library
// Interactive HSL color picker with hue wheel and saturation/lightness square
---

<div class="colorPicker" id="colorPicker">
  <div class="top">
    <!-- Hue wheel -->
    <div class="wheel" id="wheel">
      <div class="ring"></div>
      <div class="knob" id="knob"></div>
      <div class="hub">
        <div>
          <strong>HUE</strong>
          <span id="hueValue">0 degrees</span>
        </div>
      </div>
    </div>
    <!-- Saturation / Lightness -->
    <div>
      <div class="sl-wrap">
        <div class="label label-s" aria-hidden="true">Saturation</div>
        <div class="label label-l" aria-hidden="true">Lightness</div>
        <div class="sl" id="sl">
          <canvas id="slCanvas"></canvas>
          <div class="sl-cursor" id="slCursor"></div>
        </div>
      </div>
    </div>
  </div>
  <!-- swatch + CSS -->
  <div class="bottom">
    <div class="swatch" id="swatch" title="Preview swatch"></div>
    <div>
      <div class="code">
        <pre id="editor" contenteditable="plaintext-only" spellcheck="false">.elem {'{'}
background: hsl(0deg 100% 50%);
{'}'}</pre>
      </div>
    </div>
  </div>
</div>

<style id="live-style">
  .elem {
    background: hsl(0deg 100% 50%);
  }
</style>

<script>
  (() => {
    // State (HSL)
    let h = 0; // 0..360
    let s = 100; // 0..100
    let l = 50; // 0..100

    // Elements
    const colorPicker = document.getElementById('colorPicker');
    const sl = document.getElementById('sl');
    const slCanvas = document.getElementById('slCanvas');
    const slCursor = document.getElementById('slCursor');

    const wheel = document.getElementById('wheel');
    const knob = document.getElementById('knob');
    const hueValue = document.getElementById('hueValue');

    const editor = document.getElementById('editor');
    const liveStyle = document.getElementById('live-style');
    const swatch = document.getElementById('swatch');

    // Utils
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    const hslString = () => `hsl(${Math.round(h)}deg ${Math.round(s)}% ${Math.round(l)}%)`;

    // HSL -> RGB (for canvas painting)
    function hslToRgb(h0, s0, l0) {
      let r, g, b;
      if (s0 === 0) {
        r = g = b = l0;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l0 < 0.5 ? l0 * (1 + s0) : l0 + s0 - l0 * s0;
        const p = 2 * l0 - q;
        r = hue2rgb(p, q, h0 + 1 / 3);
        g = hue2rgb(p, q, h0);
        b = hue2rgb(p, q, h0 - 1 / 3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // Canvas resolution management (CSS size stays 100% of container)
    let lastCssW = 0,
      lastCssH = 0,
      lastDpr = 0;
    function ensureCanvasResolution() {
      const rect = sl.getBoundingClientRect();
      const cssW = Math.max(1, Math.round(rect.width));
      const cssH = Math.max(1, Math.round(rect.height));
      const dpr = window.devicePixelRatio || 1;

      if (cssW !== lastCssW || cssH !== lastCssH || dpr !== lastDpr) {
        slCanvas.width = Math.round(cssW * dpr);
        slCanvas.height = Math.round(cssH * dpr);
        lastCssW = cssW;
        lastCssH = cssH;
        lastDpr = dpr;
        return true;
      }
      return false;
    }

    // Draw the Saturation/Lightness square for the current hue.
    function paintSLGradient() {
      ensureCanvasResolution();
      const ctx = slCanvas.getContext('2d');
      const w = slCanvas.width;
      const hpx = slCanvas.height;

      const img = ctx.createImageData(w, hpx);
      const data = img.data;

      const H = (((h % 360) + 360) % 360) / 360;

      // Paint once per pixel (device pixels), hue-dependent only.
      for (let y = 0; y < hpx; y++) {
        const lVal = 1 - y / (hpx - 1); // top -> 1, bottom -> 0
        for (let x = 0; x < w; x++) {
          const sVal = x / (w - 1);
          const [r, g, b] = hslToRgb(H, sVal, lVal);
          const i = (y * w + x) * 4;
          data[i + 0] = r;
          data[i + 1] = g;
          data[i + 2] = b;
          data[i + 3] = 255;
        }
      }
      ctx.putImageData(img, 0, 0);
    }

    // Reposition SL cursor using the canvas' CSS size
    function positionSLCursor() {
      const rect = slCanvas.getBoundingClientRect(); // canvas content box
      const x = (s / 100) * rect.width;
      const y = (1 - l / 100) * rect.height;
      slCursor.style.left = x + 'px';
      slCursor.style.top = y + 'px';
    }

    // Update the hue wheel knob and label
    function updateWheel() {
      knob.style.setProperty('--angle', `${h}deg`);
      hueValue.textContent = `${Math.round(h)} degrees`;
    }

    // Push the color to the live CSS & preview
    function applyColor() {
      const str = hslString();
      colorPicker.style.setProperty('--h', Math.round(h) + 'deg');
      colorPicker.style.setProperty('--s', Math.round(s) + '%');
      colorPicker.style.setProperty('--l', Math.round(l) + '%');

      if (liveStyle) {
        liveStyle.textContent = `.elem { background: ${str}; }`;
      }

      if (!isTyping) {
        const next = `.elem {\n  background: ${str};\n}`;
        if (editor.textContent.trim() !== next.trim()) {
          editor.textContent = next;
          placeCaretAtEnd(editor);
        }
      }
    }

    // Initial render sequence
    function initialRender() {
      paintSLGradient();
      positionSLCursor();
      updateWheel();
      applyColor();
    }

    // Pointer logic: SL square (move cursor + update S/L + CSS)
    function setSLFromEvent(ev) {
      const rect = slCanvas.getBoundingClientRect();
      const x = clamp((ev.clientX - rect.left) / rect.width, 0, 1);
      const y = clamp((ev.clientY - rect.top) / rect.height, 0, 1);
      s = Math.round(x * 100);
      l = Math.round((1 - y) * 100);
      positionSLCursor();
      applyColor();
    }

    sl.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      sl.setPointerCapture(ev.pointerId);
      setSLFromEvent(ev);
      const move = (e) => setSLFromEvent(e);
      const up = () => {
        sl.releasePointerCapture(ev.pointerId);
        window.removeEventListener('pointermove', move);
        window.removeEventListener('pointerup', up);
      };
      window.addEventListener('pointermove', move);
      window.addEventListener('pointerup', up);
    });

    // Pointer logic: Hue wheel (rotate knob + repaint gradient + CSS)
    function setHueFromEvent(ev) {
      const rect = wheel.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const dx = ev.clientX - cx;
      const dy = ev.clientY - cy;
      let ang = (Math.atan2(dy, dx) * 180) / Math.PI; // -180..180
      ang = (ang + 450) % 360; // 0deg at top
      const prevH = h;
      h = (ang + 360) % 360;
      updateWheel();
      if (Math.round(prevH) !== Math.round(h)) paintSLGradient();
      applyColor();
    }

    wheel.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      wheel.setPointerCapture(ev.pointerId);
      setHueFromEvent(ev);
      const move = (e) => setHueFromEvent(e);
      const up = () => {
        wheel.releasePointerCapture(ev.pointerId);
        window.removeEventListener('pointermove', move);
        window.removeEventListener('pointerup', up);
      };
      window.addEventListener('pointermove', move);
      window.addEventListener('pointerup', up);
    });

    // Editor <-> UI sync
    let isTyping = false;
    editor.addEventListener('beforeinput', () => {
      isTyping = true;
    });
    editor.addEventListener('input', () => {
      const text = editor.textContent;
      const re = /hsl\(\s*([-+]?\d*\.?\d+)\s*(?:deg)?\s*[,\s]+([-+]?\d*\.?\d+)%\s*[,\s]+([-+]?\d*\.?\d+)%\s*\)/i;
      const m = text.match(re);
      if (m) {
        let [, hd, sp, lp] = m;
        const newH = ((parseFloat(hd) % 360) + 360) % 360;
        const newS = clamp(parseFloat(sp), 0, 100);
        const newL = clamp(parseFloat(lp), 0, 100);

        const hueChanged = Math.round(newH) !== Math.round(h);
        h = newH;
        s = newS;
        l = newL;

        positionSLCursor();
        updateWheel();
        if (hueChanged) paintSLGradient();
        applyColor();
      }
      isTyping = false;
    });

    // Caret helper
    function placeCaretAtEnd(el) {
      try {
        const range = document.createRange();
        range.selectNodeContents(el);
        range.collapse(false);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } catch {}
    }

    // Redraw gradient when container size (or DPR) changes
    const ro = new ResizeObserver(() => {
      paintSLGradient(); // may rescale internal buffer; CSS size unchanged
      positionSLCursor();
    });
    ro.observe(sl);

    // Handle DPR/zoom changes that may not trigger ResizeObserver
    let dpr = window.devicePixelRatio || 1;
    window.addEventListener('resize', () => {
      const now = window.devicePixelRatio || 1;
      if (now !== dpr) {
        dpr = now;
        paintSLGradient();
        positionSLCursor();
      }
    });

    // Initial paint
    initialRender();
  })();
</script>
