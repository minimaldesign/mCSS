---
// ⚠️ Internal component. Not part of mCSS component library
// Interactive HSL color picker with hue wheel and saturation/lightness square
---

<div class="colorPicker" id="colorPicker">
  <div class="top">
    <!-- Left: Saturation / Lightness -->
    <div>
      <div class="sl-wrap">
        <div class="label label-s" aria-hidden="true">Saturation</div>
        <div class="label label-l" aria-hidden="true">Lightness</div>
        <div class="sl" id="sl">
          <canvas id="slCanvas"></canvas>
          <div class="sl-cursor" id="slCursor"></div>
        </div>
      </div>
    </div>

    <!-- Right: Hue wheel -->
    <div class="wheel" id="wheel">
      <div class="ring"></div>
      <div class="knob" id="knob"></div>
      <div class="hub">
        <div>
          <strong>HUE</strong>
          <span id="hueValue">0 degrees</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Bottom: swatch + CSS -->
  <div class="bottom">
    <div class="swatch" id="swatch" title="Preview swatch"></div>
    <div>
      <div class="code">
        <pre id="editor" contenteditable="plaintext-only" spellcheck="false">.elem {'{'}
background-color: hsl(0deg 100% 50%);
{'}'}</pre>
      </div>
    </div>
  </div>
</div>

<style id="live-style">
  .elem {
    background-color: hsl(0deg 100% 50%);
  }
</style>

<style>
  .colorPicker {
    --bg: var(--base-950);
    --cp-text: var(--base-100);
    --cp-bd-color: var(--base-500);
    --cp-draggable-bd: var(--base-0);
    --cp-spacing: var(--md3);

    --h: 0; /* degrees 0–360 */
    --s: 100; /* % 0–100 */
    --l: 50; /* % 0–100 */

    --cp-wheel-size: 290px;
    --cp-wheel-thickness: 32px;
    --cp-radius: calc(var(--cp-wheel-size) / 2);

    max-width: 800px;
    padding: var(--lg1);
    border-radius: var(--radius-md);
    background: var(--bg);
  }

  .top {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--cp-spacing);
  }

  /* Section labels */
  .label {
    display: block;
    width: 100%;
    z-index: 1;
    position: absolute;
    top: 0;
    left: 0;
    color: var(--cp-text);

    text-transform: uppercase;
    text-align: center;
    font-size: 0.78rem;
    letter-spacing: 0.2em;
  }

  .label-s {
    transform: translate(0, calc(-100% - 10px));
  }

  .label-l {
    transform: rotate(-90deg) translate(-100%, calc(-100% - 10px));
    transform-origin: left top;
  }

  /* Saturation/Lightness square */
  .sl-wrap {
    position: relative;
  }

  .sl {
    aspect-ratio: 1/1;
    border: 1px solid var(--cp-bd-color);
    border-radius: var(--radius-sm);
    overflow: hidden;
    user-select: none;
    touch-action: none;

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  }

  .sl-cursor {
    position: absolute;
    width: 14px;
    height: 14px;
    border-radius: var(--radius-round);
    border: 2px solid var(--cp-draggable-bd);
    box-shadow: 0 0 0 2px hsl(0 0 0 / 0.6);
    transform: translate(-50%, -50%);
    left: 100%;
    top: 50%;
    pointer-events: none;
  }

  /* Hue wheel */
  .wheel {
    position: relative;
    width: var(--cp-wheel-size);
    height: var(--cp-wheel-size);
    margin: auto;
    user-select: none;

    .ring {
      position: absolute;
      inset: 0;
      border-radius: var(--radius-round);
      background: conic-gradient(hsl(0deg 100% 50%), hsl(60deg 100% 50%), hsl(120deg 100% 40%), hsl(180deg 100% 45%), hsl(240deg 100% 60%), hsl(300deg 100% 55%), hsl(360deg 100% 50%));
    }

    .hub {
      position: absolute;
      inset: calc(var(--cp-wheel-thickness));
      display: grid;
      place-items: center;
      text-align: center;
      background-color: var(--bg);
      border: 1px solid var(--cp-bd-color);
      border-radius: var(--radius-round);

      strong {
        display: block;
        color: var(--primary-300);
        letter-spacing: var(--tracking-xxl);
        font-size: var(--text-sm);
      }

      span {
        display: block;
        color: var(--cp-text);
        font-size: var(--text-md);
        margin-top: var(--xs1);
      }
    }
  }

  .knob {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 14px;
    height: 30px;
    transform: translate(-50%, -50%) rotate(var(--angle, 0deg)) translateY(calc(-1 * (var(--cp-radius) - var(--cp-wheel-thickness) / 2)));
    box-shadow: 0 0 0 2px hsl(0 0 0 / 0.6);
    border: 2px solid var(--cp-draggable-bd);
    border-radius: var(--radius-xl);
    pointer-events: none;
  }

  /* Bottom row */
  .bottom {
    display: grid;
    grid-template-columns: 100px 1fr;
    gap: var(--cp-spacing);
    margin-top: var(--cp-spacing);
  }

  .swatch {
    aspect-ratio: 1/1;
    border-radius: var(--radius-sm);
    background: hsl(var(--h) var(--s) var(--l));
  }

  .code {
    border: 1px solid var(--cp-bd-color);
    border-radius: var(--radius-sm);
    overflow: hidden;
  }

  .code pre {
    padding: 1em;
    white-space: pre;
    color: var(--base-50);
    background: var(--base-700);
    caret-color: var(--base-50);
  }

  .code pre:focus {
    outline: none;
  }

  @media (max-width: 880px) {
    .top {
      grid-template-columns: 1fr;
    }
    .colorPicker {
      --cp-wheel-size: 200px;
    }
    .sl-wrap {
      width: 275px;
      margin: auto;
    }
    .bottom {
      grid-template-columns: 1fr;
    }

    .swatch {
      width: 100px;
      margin: auto;
    }
  }
</style>

<script>
  (() => {
    // State (HSL)
    let h = 0; // 0..360
    let s = 100; // 0..100
    let l = 50; // 0..100

    // Elements
    const colorPicker = document.getElementById('colorPicker');
    const sl = document.getElementById('sl');
    const slCanvas = document.getElementById('slCanvas');
    const slCursor = document.getElementById('slCursor');

    const wheel = document.getElementById('wheel');
    const knob = document.getElementById('knob');
    const hueValue = document.getElementById('hueValue');

    const editor = document.getElementById('editor');
    const liveStyle = document.getElementById('live-style');
    const swatch = document.getElementById('swatch');

    // Utils
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    const hslString = () => `hsl(${Math.round(h)}deg ${Math.round(s)}% ${Math.round(l)}%)`;

    // HSL -> RGB (for canvas painting)
    function hslToRgb(h0, s0, l0) {
      let r, g, b;
      if (s0 === 0) {
        r = g = b = l0;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l0 < 0.5 ? l0 * (1 + s0) : l0 + s0 - l0 * s0;
        const p = 2 * l0 - q;
        r = hue2rgb(p, q, h0 + 1 / 3);
        g = hue2rgb(p, q, h0);
        b = hue2rgb(p, q, h0 - 1 / 3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // Canvas resolution management (CSS size stays 100% of container)
    let lastCssW = 0,
      lastCssH = 0,
      lastDpr = 0;
    function ensureCanvasResolution() {
      const rect = sl.getBoundingClientRect();
      const cssW = Math.max(1, Math.round(rect.width));
      const cssH = Math.max(1, Math.round(rect.height));
      const dpr = window.devicePixelRatio || 1;

      if (cssW !== lastCssW || cssH !== lastCssH || dpr !== lastDpr) {
        slCanvas.width = Math.round(cssW * dpr);
        slCanvas.height = Math.round(cssH * dpr);
        lastCssW = cssW;
        lastCssH = cssH;
        lastDpr = dpr;
        return true;
      }
      return false;
    }

    // Draw the Saturation/Lightness square for the current hue.
    function paintSLGradient() {
      ensureCanvasResolution();
      const ctx = slCanvas.getContext('2d');
      const w = slCanvas.width;
      const hpx = slCanvas.height;

      const img = ctx.createImageData(w, hpx);
      const data = img.data;

      const H = (((h % 360) + 360) % 360) / 360;

      // Paint once per pixel (device pixels), hue-dependent only.
      for (let y = 0; y < hpx; y++) {
        const lVal = 1 - y / (hpx - 1); // top -> 1, bottom -> 0
        for (let x = 0; x < w; x++) {
          const sVal = x / (w - 1);
          const [r, g, b] = hslToRgb(H, sVal, lVal);
          const i = (y * w + x) * 4;
          data[i + 0] = r;
          data[i + 1] = g;
          data[i + 2] = b;
          data[i + 3] = 255;
        }
      }
      ctx.putImageData(img, 0, 0);
    }

    // Reposition SL cursor using the canvas' CSS size
    function positionSLCursor() {
      const rect = slCanvas.getBoundingClientRect(); // canvas content box
      const x = (s / 100) * rect.width;
      const y = (1 - l / 100) * rect.height;
      slCursor.style.left = x + 'px';
      slCursor.style.top = y + 'px';
    }

    // Update the hue wheel knob and label
    function updateWheel() {
      knob.style.setProperty('--angle', `${h}deg`);
      hueValue.textContent = `${Math.round(h)} degrees`;
    }

    // Push the color to the live CSS & preview
    function applyColor() {
      const str = hslString();
      colorPicker.style.setProperty('--h', Math.round(h) + 'deg');
      colorPicker.style.setProperty('--s', Math.round(s) + '%');
      colorPicker.style.setProperty('--l', Math.round(l) + '%');

      if (liveStyle) {
        liveStyle.textContent = `.elem { background-color: ${str}; }`;
      }

      if (!isTyping) {
        const next = `.elem {\n  background-color: ${str};\n}`;
        if (editor.textContent.trim() !== next.trim()) {
          editor.textContent = next;
          placeCaretAtEnd(editor);
        }
      }
    }

    // Initial render sequence
    function initialRender() {
      paintSLGradient();
      positionSLCursor();
      updateWheel();
      applyColor();
    }

    // Pointer logic: SL square (move cursor + update S/L + CSS)
    function setSLFromEvent(ev) {
      const rect = slCanvas.getBoundingClientRect();
      const x = clamp((ev.clientX - rect.left) / rect.width, 0, 1);
      const y = clamp((ev.clientY - rect.top) / rect.height, 0, 1);
      s = Math.round(x * 100);
      l = Math.round((1 - y) * 100);
      positionSLCursor();
      applyColor();
    }

    sl.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      sl.setPointerCapture(ev.pointerId);
      setSLFromEvent(ev);
      const move = (e) => setSLFromEvent(e);
      const up = () => {
        sl.releasePointerCapture(ev.pointerId);
        window.removeEventListener('pointermove', move);
        window.removeEventListener('pointerup', up);
      };
      window.addEventListener('pointermove', move);
      window.addEventListener('pointerup', up);
    });

    // Pointer logic: Hue wheel (rotate knob + repaint gradient + CSS)
    function setHueFromEvent(ev) {
      const rect = wheel.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const dx = ev.clientX - cx;
      const dy = ev.clientY - cy;
      let ang = (Math.atan2(dy, dx) * 180) / Math.PI; // -180..180
      ang = (ang + 450) % 360; // 0deg at top
      const prevH = h;
      h = (ang + 360) % 360;
      updateWheel();
      if (Math.round(prevH) !== Math.round(h)) paintSLGradient();
      applyColor();
    }

    wheel.addEventListener('pointerdown', (ev) => {
      ev.preventDefault();
      wheel.setPointerCapture(ev.pointerId);
      setHueFromEvent(ev);
      const move = (e) => setHueFromEvent(e);
      const up = () => {
        wheel.releasePointerCapture(ev.pointerId);
        window.removeEventListener('pointermove', move);
        window.removeEventListener('pointerup', up);
      };
      window.addEventListener('pointermove', move);
      window.addEventListener('pointerup', up);
    });

    // Editor <-> UI sync
    let isTyping = false;
    editor.addEventListener('beforeinput', () => {
      isTyping = true;
    });
    editor.addEventListener('input', () => {
      const text = editor.textContent;
      const re = /hsl\(\s*([-+]?\d*\.?\d+)\s*(?:deg)?\s*[,\s]+([-+]?\d*\.?\d+)%\s*[,\s]+([-+]?\d*\.?\d+)%\s*\)/i;
      const m = text.match(re);
      if (m) {
        let [, hd, sp, lp] = m;
        const newH = ((parseFloat(hd) % 360) + 360) % 360;
        const newS = clamp(parseFloat(sp), 0, 100);
        const newL = clamp(parseFloat(lp), 0, 100);

        const hueChanged = Math.round(newH) !== Math.round(h);
        h = newH;
        s = newS;
        l = newL;

        positionSLCursor();
        updateWheel();
        if (hueChanged) paintSLGradient();
        applyColor();
      }
      isTyping = false;
    });

    // Caret helper
    function placeCaretAtEnd(el) {
      try {
        const range = document.createRange();
        range.selectNodeContents(el);
        range.collapse(false);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } catch {}
    }

    // Redraw gradient when container size (or DPR) changes
    const ro = new ResizeObserver(() => {
      paintSLGradient(); // may rescale internal buffer; CSS size unchanged
      positionSLCursor();
    });
    ro.observe(sl);

    // Handle DPR/zoom changes that may not trigger ResizeObserver
    let dpr = window.devicePixelRatio || 1;
    window.addEventListener('resize', () => {
      const now = window.devicePixelRatio || 1;
      if (now !== dpr) {
        dpr = now;
        paintSLGradient();
        positionSLCursor();
      }
    });

    // Initial paint
    initialRender();
  })();
</script>
