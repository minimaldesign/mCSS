---
import arrow from '../assets/icons/arrow-right-small.svg?raw';
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'nav'> {
  selector?: string;
  headings?: string[];
  baseUrl?: string;
  scrollOffset?: number;
  'data-testid'?: string;
}

// prettier-ignore
const {
  selector = 'main',
  headings = ['h2', 'h3'],
  baseUrl = '',
  scrollOffset = 0,
  'data-testid': testId = 'toc',
  ...rest
} = Astro.props as Props;
---

<!-- prettier-ignore -->
<nav
  id="toc-root"
  class="toc"
  aria-label="Table of contents"
  data-testid={testId}
  data-selector={selector}
  data-headings={JSON.stringify(headings)}
  data-base-url={baseUrl}
  data-scroll-offset={scrollOffset}
  data-arrow={encodeURIComponent(arrow)}
  {...rest}
></nav>

<script type="module">
  const tocRoot = document.getElementById('toc-root');
  const selector = tocRoot.dataset.selector;
  const headingsTags = JSON.parse(tocRoot.dataset.headings);
  const baseUrl = tocRoot.dataset.baseUrl;
  const scrollOffset = parseInt(tocRoot.dataset.scrollOffset, 10) || 0;
  const arrow = decodeURIComponent(tocRoot.dataset.arrow);

  let suppressObserver = false;
  let scrollTimeout;

  function buildTocTree(headings) {
    const root = [];
    const stack = [{ level: 0, children: root }];

    headings.forEach((heading) => {
      const level = parseInt(heading.tagName[1], 10);
      const item = {
        id: heading.id,
        text: heading.textContent,
        level,
        children: [],
      };

      while (stack.length && stack[stack.length - 1].level >= level) {
        stack.pop();
      }
      stack[stack.length - 1].children.push(item);
      stack.push(item);
    });

    return root;
  }

  function renderToc(items) {
    if (!items.length) return '';
    return `<ul>${items
      .map(
        (item) =>
          `<li>
            <a href="${baseUrl ? baseUrl + '#' + item.id : '#' + item.id}" data-toc-link="${item.id}">
            ${arrow} <span>${item.text}</span></a>
            ${renderToc(item.children)}
          </li>`
      )
      .join('')}</ul>`;
  }

  function setupToc() {
    const container = document.querySelector(selector);
    if (!container) return;

    const headings = Array.from(container.querySelectorAll(headingsTags.join(','))).filter((el) => el.id);

    const tocTree = buildTocTree(headings);
    const tocRoot = document.getElementById('toc-root');
    tocRoot.innerHTML = renderToc(tocTree);

    function updateActiveLink() {
      const hash = decodeURIComponent(window.location.hash);
      tocRoot.querySelectorAll('a[data-toc-link]').forEach((link) => {
        const href = link.getAttribute('href');
        if (hash && (href === hash || href.endsWith(hash))) {
          link.classList.add('is-active');
        } else {
          link.classList.remove('is-active');
        }
      });
    }

    tocRoot.querySelectorAll('a[data-toc-link]').forEach((link) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = link.getAttribute('data-toc-link');
        const target = document.getElementById(targetId);
        if (target) {
          suppressObserver = true;
          const rect = target.getBoundingClientRect();
          const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          const top = rect.top + scrollTop - scrollOffset;
          window.scrollTo({ top, behavior: 'smooth' });
          history.pushState(null, '', link.getAttribute('href'));
          updateActiveLink();

          // Debounced scroll event to re-enable observer
          const onScroll = () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
              suppressObserver = false;
              window.removeEventListener('scroll', onScroll);
            }, 150); // 150ms after last scroll event
          };
          window.addEventListener('scroll', onScroll);
        }
      });
    });

    window.addEventListener('hashchange', updateActiveLink);
    updateActiveLink();

    // Intersection Observer to update URL and active link on scroll
    const headingElements = headings.map((h) => document.getElementById(h.id)).filter(Boolean);

    if ('IntersectionObserver' in window && headingElements.length) {
      let ticking = false;
      const observer = new IntersectionObserver(
        (entries) => {
          if (suppressObserver) return; // <-- skip if suppressed
          if (!ticking) {
            window.requestAnimationFrame(() => {
              const visible = entries.filter((entry) => entry.isIntersecting).sort((a, b) => a.target.offsetTop - b.target.offsetTop)[0];
              if (visible) {
                const id = visible.target.id;
                if (window.location.hash !== '#' + id) {
                  history.replaceState(null, '', '#' + id);
                  updateActiveLink();
                }
              }
              ticking = false;
            });
            ticking = true;
          }
        },
        {
          rootMargin: `-${scrollOffset}px 0px 0px 0px`,
          threshold: 0.1,
        }
      );
      headingElements.forEach((el) => observer.observe(el));
    }
  }

  if (document.readyState !== 'loading') {
    setupToc();
  } else {
    window.addEventListener('DOMContentLoaded', setupToc);
  }
</script>
